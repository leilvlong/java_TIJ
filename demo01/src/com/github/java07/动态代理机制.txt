1. 实现InvocationHandler接口编写一个承接委托的类
   该类中委托者与其为组合关系

2. 使用Proxy.newProxyInstance生成动态的代理对象,其参数条件如下
    2.1. 类加载器,加载承接委托的类
    2.2. 委托者具有的接口数组,作用有两个
        2.2.1. 获取该委托者具有的行为
        2.2.2. 返回接口类型的引用
        动态代理对象不关注类型,只关心行为
    2.3. 承接委托的类的对象

3. 条件满足,JVM动态生成代理对象,对象引用类型为参数条件2.2中的接口类型
    获取动态代理对象的类名:
        System.out.println(动态代理对象.getClass().getName())
        com.github.java07.$Proxy0
    该动态代理对象声明实现了参数条件2.2中的所有接口

4. 使用该动态代理对象无论如何都会调用InvocationHandler接口的唯一方法invoke 原因如下:
    JVM生成动态代理对象时:
        4.1. 使用参数条2.1承接委托类的类加载器加载与参数条件2.2中的接口组合了一个新类
        4.2. 返回引用时返回的是参数条件2中的接口
                不然无法拥有正确的行为
        4.3. 使用时转型为InvocationHandler
           InvocationHandler只能使用invoke方法
           该invoke方法调用承接委托类的invoke方法,传入参数:
           4.3.1 代理对象
           4.3.2 执行方法
           4.3.3 方法参数
           若调用4.3.1的代理对象的方法会重走整个4.3的流程而无限递归

5. 承接委托类 以及动态代理使用实例 以方便提供理解
public class job19 {
    public static void main(String[] args) throws Throwable {
        // 承接委托对象使用
        ISA isa = new ISA();
        Prxo prxo = new Prxo(isa);
        prxo.invoke(isa,isa.getClass().getMethod("fun"),null);

        //动态代理对象使用
        ThisA o = (ThisA) Proxy.newProxyInstance(Prxo.class.getClassLoader(), new Class[]{ThisA.class}, prxo);
        o.fun();

    }
}

interface ThisA{
    void fun();
}

class ISA implements ThisA{

    @Override
    public void fun() {
        System.out.println("fun");
    }
}


class Prxo implements InvocationHandler{
    private Object obj;

    public Prxo(Object obj) {
        this.obj = obj;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //获取类名
        System.out.println(proxy.getClass().getName());

        //若使用proxy的任何方法都会无限递归 因为这个对象就是动态代理对象,原因已解释过

        //method对象使用
        method.invoke(obj,args);
        return null;
    }
}

6. 补充说明:
Proxy.newProxyInstance实际做的事实创建一个类似下面类模板这样的对象:
class MyProxy implements ThisA, InvocationHandler{
    private InvocationHandler handler;

    public MyProxy(InvocationHandler handler) {
        this.handler = handler;
    }

    @Override
    public void fun(){
    }


    针对该方法着重说明,这是关键所在
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        return handler.invoke(proxy,method,args);

        1. 调用对象方法分为三部分:
        obj.method(parameters)
        2. JVM捕获你所调用的动态代理对象($Proxy0)的这三部分
        obj  method  parameters
        3. 并动态的将该对象转型为InvocationHandler调用invoke 将这三部分传入invoke方法中执行

        由于无法模拟第2部分:
        即在执行这个方法时捕获该对象的这三部分,该场景暂时模拟不出来
        因为这是javaJVM做的事,很难猜测他对这些方法是怎么做的

    }

    硬要做的话可以通过反射获取handler中的成员委托者对象来做到
    将以上代码注释掉,模仿手动捕获执行方法时的三部分
    不要在意硬编码,只是为了举例书写方便,反射提供了大量API动态获取这些硬编码属性

    @Override
    public void fun(){

     }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        // 获取承接委托对象中的那个委托者对象
        Field obj = handler.getClass().getDeclaredField("obj");
        obj.setAccessible(true);
        Object o = obj.get(handler);
        //将其转型为需要执行的对象类型
        ThisA o1 = (ThisA) o;
        //执行方法并返回
        Object fun = handler.invoke(this, o1.getClass().getMethod("fun"), args);
        return fun;
    }
}


