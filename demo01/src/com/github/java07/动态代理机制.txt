1. 必须实现InvocationHandler接口编写一个承接委托的类
   该类与委托者为组合关系

2. 使用Proxy.newProxyInstance生成动态的代理对象,其参数条件如下
    1) 承接委托类的类加载器,加载承接委托的类
    2) 委托者具有的接口数组,作用有两个:
        1) 获取该委托者具有的行为
        2) 返回接口类型的引用
        动态代理对象不关注类型,只关心行为
    3) 承接委托类的对象

3. 以上条件满足,JVM动态生成代理对象,对象引用类型为参数条件2.2中的接口类型
    获取动态代理对象的类名:
        System.out.println(动态代理对象.getClass().getName())
    该动态代理对象声明实现了参数条件2.2中的所有接口的抽象方法

4. 使用该动态代理对象无论如何都会调用InvocationHandler接口的唯一方法invoke 原因如下:
    JVM生成动态代理对象时:
        4.1. JVM生成动态代理对象需要一个新类,该类在运行时产生,并用来创建动态代理对象
        4.2. JVM生成的类声称实现了委托者所有的接口,返回引用时向上转型为委托者具有的接口类型
                不然无法拥有正确的行为
        4.3. JVM生成的类组合了承接委托类的对象,将承接委托类的对象向上转型为InvocationHandler
           InvocationHandler只能使用invoke方法
           JVM生成的类实现的每一个方法都调用了承接委托类对象的invoke方法
           传入参数:
                1) 代理对象自身(this)
                2) 执行方法(method对象,通过堆栈信息,获取执行的方法名,使用反射获取method对象)
                    method对象具有特点:
                        不管如何获取的method对象,最终执行的对象是谁,该method对象就指向执行对象
                3) 方法参数
                因此,在承接委托类的invoke对象中若调用那个object对象就会递归
                因为一旦调用就会重走4.3流程,重走过来又调用,然后又重走,不可逆递归

5. 代码案例,分为三部分:  # job22的案例
    1) 接口、委托者、承接委托类
    2) 编译器手动实现动态代理对象
    3) 通过Api获取生成动态代理对象的类文件

